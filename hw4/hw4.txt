Author: Jun Cai
################
   PROCESSES
################

1. Where is the data structure for the process table?

The process table is in ‘proc.c’, starts from line 10. The data structure is called ‘ptable’.

2. When there is a context switch from one process to another, where are the values of the registers of the old process saved?

In the stack of the old process. 

3. What are the possible states of a process? Also, give a brief phrase describing the purpose of each state.

Possible states: UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE

UNUSED: this is for the process table entries which are not initialized yet. 
EMBRYO: this is for those newly created process entries. 
SLEEPING: this is for those processes which are waiting for I/O or other operation to be finished in order to continue running.
RUNNABLE: this is for those processes which are ready to run but waiting for an available processor.
RUNNING: this is for currently running processes on some processor.  ZOMBIE: this is for those terminated processes without any parent process waiting for it to be completed. 

4. What is the function that does a context switch between two processes?

In ‘swtch.S’, line 9, the function is called ‘swtch’ written in assembly.

5. Explain how the context switch function works.

First the swtch function read the address to save old stack pointer and the address to read new stack pointer from the input arguments, save them in registers %eax and %edx; push the registers’ values of the old process into the old stack; save old stack pointer to the given address in %eax, and read new stack pointer from the given address in %edx to the stack pointer register; finally pop the register values from the new stack. 

6. What function calls the context switch function, and explain in detail what the calling function does. (The doxygen hyper-linking is not perfect here. You may have to use 'grep' on /course/cs3650/unix-xv6/* )

The function ‘scheduler’ in line 265 of ‘proc.c’ calls swtch function. The scheduler function switches the running process on the processor by  first acquiring the lock of process table; find the next runnable process in the process table; switching TSS and page table for the chosen process; set the chosen process’s state to RUNNING; then using swtch function to switch context from scheduler to the chosen process; when it comes back to scheduler from the running process, the scheduler switch the TSS and page table, reset the chosen process variable ‘proc’.

#####################
   PROCESS STARTUP
#####################

1. Suppose a new program is going to start. This requires a call to the system call, exec(). On what lines does the operating system create the first call frame, to be used by the user process's main()?

From line 47 to 50 in ‘exec.c’. 

2. The first call frame must have local variables argc and argv. Where is the value of argv found in the exec() call?

From line 65 to 72 in ‘exec.c’.

3. On what lines does the function create the process table entry for the new process?

From line 90 to 95 in ‘exec.c’.

#####################
   SYSTEM CALLS
#####################

1. Give the full details of how a call to 'open()' in grep.c will call the function 'sys_open()' in sysfile.c, inside the operating system kernel.

ANSWER: When a call made to 'open()', the 'SYSCALL' macro in usys.S will store the system call number SYS_open (15) in %eax, then run the interrupt 'int' with argument T_SYSCALL (64). The T_SYSCALL is handled by the 64th entry in IDT (Interrupt Descriptor Table) set up specially by 'tvinit' in trap.c during system startup. The underlying data structure is 'vectors' which is generated by vectors.pl. 'vectors' stores the code address for handling different interrupt numbers. When the interrupt occurs, the processor will switch to a new stack by loading %esp and %ss from the task segment descriptor. To be able to return to user process after handling the interrupt, the user %esp , %ss and other registers are pushed to the new stack. Then %eip and %cs are loaded from the 64th IDT entry mentioned before. In 'vectors', the execution will jump to 'alltraps' in trapasm.S where a trap frame is built and 'trap(tf)' function in 'trap.c' is called with the trap frame as an argument. In 'trap', 'proc->tf' is set to the current trap frame, then 'syscall' in syscall.c is called. In 'syscall', the syscall number is retreived from 'proc->tf->eax'. Then the actual system call function is in the corresponding entry of the 'syscalls[]' array. Finally, the 'sys_open' is getting called and the result is stored back in the 'proc->tf->eax'.

################################
   FILES AND FILE DESCRIPTORS
################################


1. The function 'sys_open()' returns a file descriptor 'fd'. To do this, it opens a new file (new i-node) with 'filealloc()', and it allocates a new file descriptor with 'fdalloc()'. Where is the file descriptor allocated? Also, you will see that the file descriptor is one entry in an array. What is the algorithm used to choose which entry in the array to use for the new file descriptor? [ Comment: The name 'NOFILE' means "file number". "No." is sometimes used as an abbreviation for the word "number". ]

Line 44 in ‘sysfile.c’, the file descriptor is allocated in the process’s open file array.
From the first entry to the last entry of the open file array, find the first empty entry then use it for the new file descriptor.

2. As you saw above, the file descriptor turned out to be an index in an array. What is the name of the array for which the file descriptor is an index? Also, what is the type of one entry in that array.

ofile in struct 'proc' in ‘proc.h’ line 66.
file structure in ‘file.h’ line 1.

3. The type that you saw in the above question is what I was calling a "file handle" (with an offset into the file, etc.). What is the name of the field that holds the offset into the file? We saw it in the function 'sys_open()'.

'off'

4. Remember when we mentioned a call to 'filealloc()' above? Since the return value of 'filealloc()' is only a file handle, we need to initialize it. Presumably, we will initialize it with a file offset of 0. What is the line number in 'sys_open()' where we initialize the file offset to 0?

Line 327 in ‘sysfile.c’

5. The file handle type was initialized to 'FD_INODE'. What are the other types that it could have been initialized to?

FD_NONE, FD_PIPE

6. Suppose a file handle had been initialized to FD_PIPE. Find the 'struct' that holds the information about a pipe. For each field in that struct, Explain briefly (just a phrase) the purpose of that field.

Line 12 ‘pip.c’, Struct ‘pipe’. 
Spinlock Lock -- lock to ensure automical manipulation
Char Data[] -- bufferred data
Nread -- number of bytes read
Nwrite -- number of bytes write
Readopen -- read fd is still open
writeopen -- write fd is still open

7. By examining the function 'sys_dup()', you can discover how a system call to 'dup()' will manipulate both a file descriptor and a "file handle". Describe what it does in each of the two cases.

For 'file handle', increase the reference number 'ref' by one.
For 'file descriptor', find an empty entry in 'ofile' array of the proccess, point it to the 'file handle' and return the index as the new file descriptor.
